Append(l1, l2) =
  case l1 (
    nil -> l2
  | cons(h, t) -> cons(h, Append(t, l2))
  )
;

Snoc(l, b) =
  case l (
    nil -> cons(b, nil)
  | cons(h, t) -> cons(h, Snoc(t, b))
  )
;

AppendSlow(l1, l2) =
  case l2 (
    nil -> l1
  | cons(h, t) -> AppendSlow(Snoc(l1, h), t)
  )
;

RevAux(l, acc) =
  case l (
    nil -> acc
  | cons(h, t) -> RevAux(t, cons(h, acc))
  )
;

Reverse(l) = RevAux(l, nil);

Le(l1, l2) =
  case l1 (
    nil -> true * nil * l2
  | cons(h1, t1) ->
    case l2 (
      nil -> false * cons(h1, t1) * nil
    | cons(h2, t2) ->
      let cmp * tmp = Le(t1, t2) in
      let t1 * t2 = tmp in
      cmp * cons(h1, t1) * cons(h2, t2)
    )
  )
;

Insert(x, l) =
  case l (
    nil -> cons(x, nil)
  | cons(y, t) ->
    let cmp * tmp = Le(x, y) in
    let x * y = tmp in
    if cmp
    then cons(x, cons(y, t))
    else cons(y, Insert(x, t))
  )
;

Sort(l) =
  case l (
    nil -> nil
  | cons(h, t) -> Insert(h, Sort(t))
  )
;

AppTail(f, l) =
  case l (
    nil -> nil
  | cons(h, t) ->
    case t (
      nil -> cons(f(h), nil)
    | cons(h', t') -> cons(h, AppTail(f, cons(h', t')))
    )
  )
;

ComposeList(l) =
  case l (
    nil -> fun a -> a
  | cons(f, t) -> fun a -> f(ComposeList(t)(a))
  )
;

Dup2(l: list(bool)) =
  case l (
    nil -> nil
  | cons(h, t) -> cons(h, cons(h, Dup2(t)))
  )
;

DupExp(l) =
  case l (
    nil -> cons(true, nil)
  | cons(h, t) -> Dup2(DupExp(t))
  )
;

Copy2(l: list(bool)) =
  case l (
    nil -> nil * nil
  | cons(h, t) ->
    let l1 * l2 = Copy2(t) in
    cons(h, l1) * cons(h, l2)
  )
;

SelfAppend2(l) =
  let l1 * l2 = Copy2(l) in
  Append(l1, l2)
;

Copy3(l: list(bool)) =
  case l (
    nil -> nil * nil * nil
  | cons(h, t) ->
    let l1 * tmp = Copy3(t) in
    let l2 * l3 = tmp in
    cons(h, l1) * cons(h, l2) * cons(h, l3)
  )
;

SelfAppend3(l) =
  let l1 * tmp = Copy3(l) in
  let l2 * l3 = tmp in
  Append(l1, Append(l2, l3))
;

SelfAppend3Slow(l) =
  let l1 * tmp = Copy3(l) in
  let l2 * l3 = tmp in
  Append(Append(l1, l2), l3)
;

Infinite() = Infinite();
